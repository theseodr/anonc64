/**
 * Minified by jsDelivr using Terser v5.39.0.
 * Original file: /npm/y-webrtc@10.0.2/dist/y-webrtc.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
"use strict";function _interopDefault(e){return e&&"object"==typeof e&&"default"in e?e.default:e}Object.defineProperty(exports,"__esModule",{value:!0});var ws=require("lib0/dist/websocket.js"),map=require("lib0/dist/map.js"),error=require("lib0/dist/error.js"),random=require("lib0/dist/random.js"),encoding=require("lib0/dist/encoding.js"),decoding=require("lib0/dist/decoding.js"),observable_js=require("lib0/dist/observable.js"),logging=require("lib0/dist/logging.js"),promise=require("lib0/dist/promise.js");require("yjs");var Peer=_interopDefault(require("simple-peer/simplepeer.min.js")),syncProtocol=require("y-protocols/dist/sync.js"),awarenessProtocol=require("y-protocols/dist/awareness.js"),buffer=require("lib0/dist/buffer.js"),string=require("lib0/dist/string.js");const deriveKey=(e,n)=>{const r=string.encodeUtf8(e).buffer,o=string.encodeUtf8(n).buffer;return crypto.subtle.importKey("raw",r,"PBKDF2",!1,["deriveKey"]).then((e=>crypto.subtle.deriveKey({name:"PBKDF2",salt:o,iterations:1e5,hash:"SHA-256"},e,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])))},encrypt=(e,n)=>{const r=crypto.getRandomValues(new Uint8Array(12)),o=encoding.createEncoder();encoding.writeAny(o,e);const s=encoding.toUint8Array(o);return crypto.subtle.encrypt({name:"AES-GCM",iv:r},n,s).then((e=>{const n=encoding.createEncoder();return encoding.writeVarString(n,"AES-GCM"),encoding.writeVarUint8Array(n,r),encoding.writeVarUint8Array(n,new Uint8Array(e)),buffer.toBase64(encoding.toUint8Array(n))}))},decrypt=(e,n)=>{if("string"!=typeof e)return promise.reject();const r=decoding.createDecoder(buffer.fromBase64(e));"AES-GCM"!==decoding.readVarString(r)&&promise.reject(error.create("Unknown encryption algorithm"));const o=decoding.readVarUint8Array(r),s=decoding.readVarUint8Array(r);return crypto.subtle.decrypt({name:"AES-GCM",iv:o},n,s).then((e=>decoding.readAny(decoding.createDecoder(new Uint8Array(e)))))},log=logging.createModuleLogger("y-webrtc"),messageSync=0,messageQueryAwareness=3,messageAwareness=1,signalingConns=new Map,rooms=new Map,checkIsSynced=e=>{let n=!0;e.webrtcConns.forEach((e=>{e.synced||(n=!1)})),(!n&&e.synced||n&&!e.synced)&&(e.synced=n,e.provider.emit("synced",[{synced:n}]),log("synced ",logging.BOLD,e.name,logging.UNBOLD," with all peers"))},readPeerMessage=(e,n)=>{const r=decoding.createDecoder(n),o=encoding.createEncoder(),s=decoding.readVarUint(r),t=e.room;if(log("received message from ",logging.BOLD,e.remotePeerId,logging.GREY," ("+t.name+")",logging.UNBOLD,logging.UNCOLOR," message type: ",logging.BOLD,s),void 0===t)return null;const i=t.provider,c=t.doc;let a=!1;switch(s){case 0:encoding.writeVarUint(o,0);const n=syncProtocol.readSyncMessage(r,o,c,t.provider);n!==syncProtocol.messageYjsSyncStep2||t.synced||(e.synced=!0,log("synced ",logging.BOLD,t.name,logging.UNBOLD," with ",logging.BOLD,e.remotePeerId),checkIsSynced(t)),n===syncProtocol.messageYjsSyncStep1&&(a=!0);break;case 3:encoding.writeVarUint(o,1),encoding.writeVarUint8Array(o,awarenessProtocol.encodeAwarenessUpdate(i.awareness,Array.from(i.awareness.getStates().keys()))),a=!0;break;case 1:awarenessProtocol.applyAwarenessUpdate(i.awareness,decoding.readVarUint8Array(r),i);break;default:return console.error("Unable to compute message"),o}return a?o:null},sendWebrtcConn=(e,n)=>{log("send message to ",logging.BOLD,e.remotePeerId,logging.UNBOLD,logging.GREY," (",e.room.name,")",logging.UNCOLOR),e.peer.send(encoding.toUint8Array(n))},broadcastWebrtcConn=(e,n)=>{log("broadcast message in ",logging.BOLD,e.name,logging.UNBOLD);const r=encoding.toUint8Array(n);e.webrtcConns.forEach((e=>{e.peer.send(r)}))};class WebrtcConn{constructor(e,n,r,o){log("establishing connection to ",logging.BOLD,r),this.room=o,this.remotePeerId=r,this.closed=!1,this.connected=!1,this.synced=!1,this.peer=new Peer({initiator:n}),this.peer.on("signal",(n=>{publishSignalingMessage(e,o,{to:r,from:o.peerId,type:"signal",signal:n})})),this.peer.on("connect",(()=>{log("connected to ",logging.BOLD,r),this.connected=!0;const e=o.provider,n=e.doc,s=e.awareness,t=encoding.createEncoder();encoding.writeVarUint(t,0),syncProtocol.writeSyncStep1(t,n),sendWebrtcConn(this,t);const i=s.getStates();if(i.size>0){const e=encoding.createEncoder();encoding.writeVarUint(e,1),encoding.writeVarUint8Array(e,awarenessProtocol.encodeAwarenessUpdate(s,Array.from(i.keys()))),sendWebrtcConn(this,e)}})),this.peer.on("close",(()=>{this.connected=!1,this.closed=!0,o.webrtcConns.delete(this.remotePeerId),checkIsSynced(o),this.peer.destroy(),log("closed connection to ",logging.BOLD,r)})),this.peer.on("error",(e=>{log("error in connection to ",logging.BOLD,r,": ",e)})),this.peer.on("data",(e=>{const n=readPeerMessage(this,e);null!==n&&sendWebrtcConn(this,n)}))}}class Room{constructor(e,n,r,o){this.peerId=random.uuidv4(),this.doc=e,this.provider=n,this.synced=!1,this.name=r,this.key=o,this.webrtcConns=new Map}}const openRoom=(e,n,r,o)=>{if(rooms.has(r))throw error.create(`A Yjs Doc connected to room "${r}" already exists!`);const s=new Room(e,n,r,o);return rooms.set(r,s),signalingConns.forEach((e=>{e.connected&&(e.send({type:"subscribe",topics:[r]}),publishSignalingMessage(e,s,{type:"announce",from:s.peerId}))})),s},publishSignalingMessage=(e,n,r)=>{n.key?encrypt(r,n.key).then((r=>{e.send({type:"publish",topic:n.name,data:r})})):e.send({type:"publish",topic:n.name,data:r})};class SignalingConn extends ws.WebsocketClient{constructor(e){super(e),this.providers=new Set,this.on("connect",(()=>{const e=Array.from(rooms.keys());this.send({type:"subscribe",topics:e}),rooms.forEach((e=>publishSignalingMessage(this,e,{type:"announce",from:e.peerId})))})),this.on("message",(e=>{if("publish"===e.type){const n=e.topic,r=rooms.get(n);if(null==r||"string"!=typeof n)return;const o=e=>{const n=r.webrtcConns,o=r.peerId;if(null!=e&&e.from!==o&&(void 0===e.to||e.to===o))switch(e.type){case"announce":map.setIfUndefined(n,e.from,(()=>new WebrtcConn(this,!0,e.from,r)));break;case"signal":e.to===o&&map.setIfUndefined(n,e.from,(()=>new WebrtcConn(this,!1,e.from,r))).peer.signal(e.signal)}};r.key?decrypt(e.data,r.key).then(o):o(e.data)}})),this.on("connect",(()=>log(`connected (${e})`))),this.on("disconnect",(()=>log(`disconnect (${e})`)))}}class WebrtcProvider extends observable_js.Observable{constructor(e,n,{signaling:r=["wss://signaling.yjs.dev","wss://y-webrtc-uchplqjsol.now.sh","wss://y-webrtc-signaling-eu.herokuapp.com","wss://y-webrtc-signaling-us.herokuapp.com"],password:o=null}={}){super(),this.roomName=e,this.doc=n,this.signalingConns=[],this.key=o?deriveKey(o,e):promise.resolve(null),r.forEach((e=>{const n=map.setIfUndefined(signalingConns,e,(()=>new SignalingConn(e)));this.signalingConns.push(n),n.providers.add(this)})),this.room=null,this.key.then((r=>{this.room=openRoom(n,this,e,r)})),this.awareness=new awarenessProtocol.Awareness(n),this._docUpdateHandler=(e,n)=>{if(null!==this.room&&(n!==this||null===n)){const n=encoding.createEncoder();encoding.writeVarUint(n,0),syncProtocol.writeUpdate(n,e),broadcastWebrtcConn(this.room,n)}},this._awarenessUpdateHandler=({added:e,updated:n,removed:r},o)=>{if(null!==this.room){const o=e.concat(n).concat(r),s=encoding.createEncoder();encoding.writeVarUint(s,1),encoding.writeVarUint8Array(s,awarenessProtocol.encodeAwarenessUpdate(this.awareness,o)),broadcastWebrtcConn(this.room,s)}},this.doc.on("update",this._docUpdateHandler),this.awareness.on("change",this._awarenessUpdateHandler),window.addEventListener("beforeunload",(()=>{awarenessProtocol.removeAwarenessStates(this.awareness,[n.clientID],"window unload")}))}destroy(){super.destroy(),this.signalingConns.forEach((e=>{e.providers.delete(this),0===e.providers.size?(e.destroy(),signalingConns.delete(this.roomName)):e.send({type:"unsubscribe",topics:[this.roomName]})})),this.key.then((()=>{rooms.delete(this.roomName)})),this.doc.off("update",this._docUpdateHandler),this.awareness.off("change",this._awarenessUpdateHandler),super.destroy()}}exports.Room=Room,exports.SignalingConn=SignalingConn,exports.WebrtcConn=WebrtcConn,exports.WebrtcProvider=WebrtcProvider;
//# sourceMappingURL=/sm/c4e63989e574ef795d9a321ab509fb36f286be94a6a2b6b3b2b772128f037d68.map